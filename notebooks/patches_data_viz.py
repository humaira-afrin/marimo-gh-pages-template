# /// script
# requires-python = ">=3.12"
# dependencies = [
#     "marimo==0.13.15",
#     "polars==1.30.0",
#     "altair==4.2.0",
#     "pandas==2.3.0",
# ]
# //
import marimo

__generated_with = "0.13.15"
app = marimo.App(width="medium")

@app.cell
def _():
    import marimo as mo
    import pandas as pd
    import polars as pl
    import os
    import matplotlib.pyplot as plt
    return mo, pd, pl, os, plt


@app.cell
def _():
    mo.md(
        r"""
        ### Notebook Summary

        This notebook performs data analysis on a dataset of program repair patches.

        #### Data Source

        The notebook reads from:
        
        ```
        ../results/smartbugs/data_analysis/patches_w_require.csv
        ```

        This CSV file contains structured data on patches automatically generated by various repair tools and includes the following columns:

        - `Tool`: Name of the automated repair tool that generated the patch.
        - `Category`: Classification of the underlying bug being patched.
        - `Patch`
        - `GitHub Link`
        - `ChangeType`: Type of change made (`Added`, `Modified`, etc.).
        - `CodeLine`
        - `RequireType`: Type or context of `require` used in the patch (e.g., Invariant, modifier,).

        #### Data Analysis

        The notebook conducts several grouped aggregations to understand the structure and distribution of the patch data:

        1. **Raw Table Display**:
            - Shows the full content of the dataset 

        2. **Patch Counts by Change Type**:
            - Aggregates and displays the number of patches that were `Added`, `Modified`, etc.

        3. **Patch Counts by Tool**:
            - Shows how many patches each repair tool produced.

        4. **Tool vs. Change Type Breakdown**:
            - Creates a pivot table showing how each tool's patches are distributed across different change types.

        5. **Bug Category Distribution**:
            - Displays the frequency of each bug category in the dataset.

        6. **Require Type vs. Bug Category**:
            - Produces a pivot table showing how different `require` types are used across bug categories.

        """
    )
    return


@app.cell
def _(mo, pl):
    inv_df = pl.read_csv(str(mo.notebook_location() / "public" / "patches_w_require.csv"),infer_schema_length=10000)
    return inv_df

@app.cell
def _(inv_df):
    inv_df
    return inv_df

@app.cell
def _(inv_df, pl):
    counts = (
        inv_df
        .group_by("ChangeType")
        .agg(pl.len().alias("Count"))  
    )
    counts
    return counts

@app.cell
def _(inv_df, pl):
    tool_counts = (
        inv_df
        .group_by("Tool")
        .agg(pl.len().alias("PatchCount")) 
        .sort("PatchCount", descending=True)
    )
    tool_counts
    return tool_counts

@app.cell
def _(inv_df, pl):
    tool_change = (
        inv_df
        .group_by(["Tool", "ChangeType"])
        .agg(pl.len().alias("Count"))  
        .pivot(values="Count", index="Tool", on="ChangeType")
        .fill_null(0)
    )
    tool_change
    return tool_change

@app.cell
def _(inv_df, pl):
    category_counts = (
        inv_df
        .group_by("Category")
        .agg(pl.len().alias("Count")) 
        .sort("Count", descending=True)
    )
    category_counts
    return category_counts

@app.cell
def _(inv_df, pl):
    req_cat = (
        inv_df
        .group_by(["RequireType", "Category"])
        .agg(pl.len().alias("Count"))  # and here
        .pivot(values="Count", index="RequireType", on="Category") 
        .fill_null(0)
    )
    req_cat
    return req_cat

if __name__ == "__main__":
    app.run()
