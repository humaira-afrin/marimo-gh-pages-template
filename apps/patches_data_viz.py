import marimo

__generated_with = "0.13.15"
app = marimo.App(width="medium")

@app.cell
def _():
    import marimo as mo
    import pandas as pd
    import polars as pl
    import os
    import matplotlib.pyplot as plt
    return mo, pd, pl, os, plt

@app.cell
def _(mo):
    return mo.md("""
### Notebook Summary

This notebook performs data analysis on a dataset of program repair patches.

#### Data Source

The notebook reads from:
 
```
../results/smartbugs/data_analysis/patches_w_require.csv
```

This CSV file contains structured data on patches automatically generated by various repair tools and includes the following columns (among others):

- `Tool`: Name of the automated repair tool that generated the patch.
- `Category`: Classification of the underlying bug being patched.
- `Patch`
- `GitHub Link`
- `ChangeType`: Type of change made (`Added`, `Modified`, etc.).
- `CodeLine`
- `RequireType`: Type or context of `require` used in the patch (e.g., precondition, assertion).

#### Data Analysis

The notebook conducts several grouped aggregations to understand the structure and distribution of the patch data:

1. **Raw Table Display**:
    - Shows the full content of the dataset (`inv_df`) as a Polars DataFrame.

2. **Patch Counts by Change Type**:
    - Aggregates and displays the number of patches that were `Added`, `Modified`, etc.

3. **Patch Counts by Tool**:
    - Shows how many patches each repair tool produced.

4. **Tool vs. Change Type Breakdown**:
    - Creates a pivot table showing how each tool's patches are distributed across different change types.

5. **Bug Category Distribution**:
    - Displays the frequency of each bug category in the dataset.

6. **Require Type vs. Bug Category**:
    - Produces a pivot table showing how different `require` types are used across bug categories.
"""
)


@app.cell
def _(mo, pl):
    inv_df = pl.read_csv(str(mo.notebook_location() / "public" / "patches_w_require.csv"),infer_schema_length=10000)
    return inv_df

@app.cell
def _(inv_df):
    inv_df
    return inv_df

@app.cell
def _(inv_df, pl):
    counts = (
        inv_df
        .group_by("ChangeType")
        .agg(pl.len().alias("Count"))  
    )
    counts
    return counts

@app.cell
def _(inv_df, pl):
    tool_counts = (
        inv_df
        .group_by("Tool")
        .agg(pl.len().alias("PatchCount")) 
        .sort("PatchCount", descending=True)
    )
    tool_counts
    return tool_counts

@app.cell
def _(inv_df, pl):
    tool_change = (
        inv_df
        .group_by(["Tool", "ChangeType"])
        .agg(pl.len().alias("Count"))  
        .pivot(values="Count", index="Tool", on="ChangeType")
        .fill_null(0)
    )
    tool_change
    return tool_change

@app.cell
def _(inv_df, pl):
    category_counts = (
        inv_df
        .group_by("Category")
        .agg(pl.len().alias("Count")) 
        .sort("Count", descending=True)
    )
    category_counts
    return category_counts

@app.cell
def _(inv_df, pl):
    req_cat = (
        inv_df
        .group_by(["RequireType", "Category"])
        .agg(pl.len().alias("Count"))  # and here
        .pivot(values="Count", index="RequireType", on="Category") 
        .fill_null(0)
    )
    req_cat
    return req_cat

if __name__ == "__main__":
    app.run()
